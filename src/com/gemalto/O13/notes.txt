==============================================
Collection
       ->Set
           ->SortedSet
       ->List (Ordered collection of item that can contain duplicates)
           ->ArrayList
           ->LinkedList
       ->Queue
       ->Deque


Map
   ->SortedMap
==============================================
In Theatre class,
private List<Seat> seats = new ArrayList<>();

ArrayList
LinkedList

Changed: List -> Collection (more generic)

HashSet
LinkedHashSet


TreeSet - error (ClassCastException: because requires to implement Comparable interface on Seat)




Collections methods:
    reverse
    shuffle
    sort
    swap
    (copy -> not useful in general)
    copy(List<? super T> dest, List<? extends T> src)
         dest -> Collections/ Iterable/ List
         src  -> List


Comparator can be in a new class or create an object(anonymous class) within some other class as here.
Beware of the problem: Ordering being consistent with equals
---------------------
Explaination:
--------------
In Seat -> public int compareTo(Seat seat) {...} returns 0 if same seat number
In Comparator's comapare() , it is not consistent with equals (it returns 0 when seats have same price)
            @Override
            public int compare(Seat seat1, Seat seat2) {
                if (seat1.getPrice() < seat2.getPrice()) {
                    return -1;
                } else if (seat1.getPrice() > seat2.getPrice()) {
                    return 1;
                } else {
                    return 0;
                }
            }

Fix:
--------
More work required on the compare()




Map
========================
can have a single unique key (no duplication) -> if try to duplicate, the new value will overwrite the old value
each key has single value

Map's methods:
---------------
put
get
containsKey
keySet
remove
replace


Immutable objects can't be changed (prefered to be as a map's keys, although Java don't prohibit that)


Immutable class means that they can't be changed once they are created.
Its a great way :
    1. to increase encapsulation
    2. to reduce errors if one allow external code to modify class instances

Strategy to define immutable classes:
    1. No setter method
    2. Make fields -> final & private
    3. Don't allow sub-classes to override methods
                (a) declare class -> final
                (b) constructor -> private, & construct instances in factory methods
    4.



Sets & HashSets
====================
Unlike List (Ordered collection of item that can contain duplicates),
Set has following characteristics:
    1. No defined ordering (un-ordered)
    2. Can not contain duplicates
    3. It takes single type Set<T>
    4. Common methods-
                       add()
                       remove()
                       clear()
                       size()
                       isEmpty()
                       contains() -> can check if something exists
    5. Can't retrieve items from Set using index, can check if something exists
    6. HashSet - most common implementation




